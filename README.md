# rintp
rintp

# usage

$ make

to compile the source and obtain the executable "rintp". I succeed to compile them in the following environment:

* gcc 8.2.0 on CentOS 7
* gcc 5.4.0 on Ubuntu 16.04

then

$ ./rintp "CCCCAAAAGGGG" "((((....))))" 12 RintPwithDFT

# output

If the input is valid, output is given from Standard Output in the following format:

> R  
> 0 z[0]  
> 1 z[1]  
> :  
> (R-1) z[R-1]  
> 0 0 bulge P[0][0]["bulge"]  
> 0 0 exterior P[0][0]["exterior"]  
> 0 0 hairpin P[0][0]["hairpin"]  
> 0 0 internal P[0][0]["internal"]  
> 0 0 multi P[0][0]["multi"]  
> 0 0 stem P[0][0]["stem"]  
> 0 (N-1) bulge P[0][N-1]["bulge"]  
> :  
> 0 (N-1) stem P[0][N-1]["stem"]  
> :  
> (R-1) (N-1) bulge P[R-1][N-1]["bulge"]  
> :  
> (R-1) (N-1) stem P[R-1][N-1]["stem"]  

where z[] is the array of Boltmann probabilities and P[][][] is the array of decomposed structural profiles.

# miscellaneous notes

Excuse me to note in Japanese below.

### メモ化再帰について

動的計画法とメモ化再帰が密接に関係していることは皆さんご存知かと思います。

本リポジトリ内のコードではほぼ全てのアルゴリズムが、ラムダ式でメモ化再帰するスタイルでコーディングされています。ラムダ式を多用した理由は２つあって、ひとつは可読性のためです。すなわち、
- 核心的なアルゴリズムが一つの大きな関数に収まっていて、
- そのなかにラムダ式で補助関数が実装されていて、
- ラムダ式のキャプチャ範囲は関数内のみになっている
ならば、「その一つの関数を読むだけでアルゴリズムの実装を理解できる」ことが保証されるので分かりやすいのではと思ったからです。

もうひとつの理由は、論文内でのアルゴリズムの記述のされかたが、ラムダ式によるメモ化再帰に最も近いからです。

ラムダ式でメモ化再帰するスタイルには速度上の問題もあります。普通のラムダ式は自分以降に書かれたラムダ式を呼び出せないので、ラムダ式で再帰するためにRintCでは「std::functionによるラムダ式の宣言」を用いました。ちなみにですが、この方法は遅いらしいです。

https://koturn.hatenablog.com/entry/2018/06/10/060000

このブログで最初に紹介されている手法が、私が利用した手法です。でもたかだか定数倍ですし、定数倍高速化を求めるならそもそも動的計画法にすべきでしょう。結局のところ、論文の通りに実装されることにより可読性が増すほうが利益が大きいという当時の判断は間違っていなかったと今でも思っています。

### パラメータについて

パラメータ絡みの実装は、parasor_param名前空間のなかにまとまっています。ほとんどの変数・関数がstaticになっていて、staticじゃない関数は最初の方と最後のいくつかだけです。

最初の方の関数ですが、コメントアウトされている処理と等価な表引きを行っています。

Energy関数は、設定温度TTのときのギブズエネルギーを求める関数です。エンタルピー H、熱力学温度 T、エントロピー S として、ギブズエネルギーGはG=H-TSで定義されます。(日本語版wikipediaに書いてありました)　一方、ターナーパラメータでは「エンタルピー」と「摂氏37度のときのギブズエネルギー」の2つの値が提供されます。ここから算数的な式変形を頑張ると、「設定温度におけるギブズエネルギー」を求められます。

真ん中らへんのゴチャゴチャはparasorのコードを頑張って読解して移植したものですが、今の私にはすぐには説明できません。(もちろん、Rint(C|P)論文の記述に対して正しいコードになっていることは過去の私がしっかり確認しました。)パラメータファイルのテキストを読み込むパーサーと、その値を解釈してテーブルに格納する処理があったような記憶があります。

「ターナーパラメータ」と呼ばれている.par形式のテキストファイルですけど、もともとはVienna RNA Packageに入っているファイルですが、個人的には酷いファイルだと思っていまして、最低でもJSONとか何らかの「文法仕様が定まっている形式」で提供されるべきでしょう。そうすればパーサーに既存のライブラリを使えますし。あと、バージョンごとに文法規則が微妙に違うのも悪い意味でヤバいです。（新しい.parファイルがpublishされるたびに各ツールのパーサーにそれ用の調整を加える必要があるので）

各パラメータがどんな意味なのか（int12って何だよみたいな）、どうやって導出されているのか（例えばどれが実験データでどれが内挿なのかとか）といった情報も、.parファイルと一緒に提供されているべきでしょう。それこそ.parファイルの末尾とかに文書で書かれているとか、JSONなら各データにラベルを振ってschemaで説明するとか。

### kvライブラリについて

Rint(C|P)では数値誤差の上界を求めるために区間演算を使っています。区間演算ライブラリとしてkvライブラリというのを採用しました。この採用理由は単にkvライブラリがヘッダオンリーライブラリだったからです。というのも、当時の私はVisual Studioで開発したくて、でもそこにGMPとかをインストールする方法がわからず、ヘッダオンリーなら導入できたのでした。kvライブラリの区間演算の実装が正当であることは過去の私がしっかり確かめましたし、ヘッダオンリーのほうが導入しやすいのは確かに利点ではありますが、それはそれとして、今の私ならGMPベースの鉄板のライブラリを使うと思います。（GMPベースのMPFRベースの）MPFIというライブラリが区間演算の鉄板ライブラリだと認識しています。

### assertの多用について

現在のコードでは、ユーザーからの入力をvalidateするときにassertを使っています。ゆえに、ユーザーが不正な入力（例えば配列と構造が矛盾してるとか）をすると、引っかかったassertの行番号だけが表示されてクラッシュします。

プログラミング作法に関する現在の私の理解では、「『assertに引っかかる』⇒『自分のプログラム内にバグがある』」という命題が必ず成り立つと確信できる場合にのみassertを使うべきです。（そういう場合はassertを積極的に入れるべきです。）対偶で言い換えると、ユーザーからの入力をvalidateするときなんかにはassertを使ってはいけなくて、例外処理などで対応すべきです。

（余談）一人で開発している場合、ユーザーからのコマンドライン入力とかを最初にバリデーションしてしまえば、残りのアルゴリズムの核心部分はすべてassertでかまわないと思います。一方、アルゴリズムの核心部分を切り分けて複数人で開発している場合は、他の開発者がエンバグしている可能性は例外処理で検知して、『自分の』プログラムにバグがある場合のみassertで検知する、あたりが良いんですかね？
